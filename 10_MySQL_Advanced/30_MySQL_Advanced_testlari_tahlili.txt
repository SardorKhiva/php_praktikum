    {
1. Operatsiyalarning qaysi biri triggerlarda ko'rsatilmaydi?
UPDATE
INSERT
DELETE
ALTER       -- <--
    }

    {
2. MySQL da nechta join turlari bor?
}
4       -- bu xato ekan
5
6       -- bu to'g'ri

MySQL da JOIN operatori quyidagi asosiy turlarga boâ€˜linadi:

INNER JOIN â€“ Ikkala jadvaldagi mos keluvchi maâ€™lumotlarni chiqaradi.
LEFT JOIN (LEFT OUTER JOIN) â€“ Chap jadvaldagi barcha yozuvlarni va
oâ€˜ng jadvaldagi mos keluvchi yozuvlarni chiqaradi.

RIGHT JOIN (RIGHT OUTER JOIN) â€“ Oâ€˜ng jadvaldagi barcha yozuvlarni va
chap jadvaldagi mos keluvchi yozuvlarni chiqaradi.

FULL JOIN (FULL OUTER JOIN) â€“ Chap va oâ€˜ng jadvaldagi barcha yozuvlarni
chiqaradi (MySQL da toâ€˜gâ€˜ridan-toâ€˜gâ€˜ri qoâ€˜llab-quvvatlanmaydi, UNION yordamida amalga oshiriladi).

CROSS JOIN â€“ Har bir jadvalning har bir qatori bilan barcha
kombinatsiyalarni chiqaradi (kartesian koâ€˜paytma).

SELF JOIN â€“ Bitta jadval ichida qoâ€˜llaniladi, oâ€˜ziga oâ€˜zi bogâ€˜langan holda ishlaydi.

Koâ€˜p hollarda INNER JOIN va LEFT JOIN eng koâ€˜p ishlatiladigan turlar hisoblanadi.
    }

    {
3. Quyidagilardan qaysi biri taqqoslash operatori emas?
==      -- tenglikka tekshirish, taqqoslash
=       -- o'zlashtirish, shu javob
<=      -- kichik yoki teng
>=      -- katta yoki teng
    }

    {
4. Index lar qanday so'rovlarni tezlashitirishda yordam beradi?
Ma'lumotlarni insert qilishda
Ma'lumotlarni filter qilishda       -- <--
Index langan ustunlarni ALTER qilishda

Indexlar asosan ma'lumotlarni filter qilishda
soâ€˜rovlarning tez ishlashiga yordam beradi.

1ï¸âƒ£ Ma'lumotlarni filter qilishda âœ… (Tezlashtiradi)
Indexlar WHERE, JOIN, ORDER BY, GROUP BY kabi operatorlar bilan
ishlaydigan soâ€˜rovlarni sezilarli darajada tezlashtiradi.
Index qilingan ustun boâ€˜yicha qidiruv qilish,
indeks boâ€˜lmagan ustunga nisbatan ancha tez bajariladi,
chunki MySQL butun jadvalni skanerlash oâ€˜rniga
indeksga qarab tezroq natijani topadi.
Misol:

CREATE INDEX idx_name ON users(name);
SELECT * FROM users WHERE name = 'Ali';

Natija: Ushbu soâ€˜rov endi toâ€˜liq jadvalni skanerlash oâ€˜rniga
indeksdan foydalangan holda tezroq ishlaydi.

2ï¸âƒ£ Ma'lumotlarni insert qilishda âŒ (Sezilarli darajada sekinlashtiradi)
Har safar INSERT, UPDATE, DELETE amallari bajarilganda,
indekslar ham yangilanishi kerak boâ€˜ladi,
bu esa qoâ€˜shimcha vaqt talab qiladi.
Agar jadvalda koâ€˜p indekslar boâ€˜lsa,
ma'lumot qoâ€˜shish va oâ€˜zgartirish jarayoni sekinlashadi.
Shuning uchun: Agar tez-tez ma'lumot qoâ€˜shiladigan jadval boâ€˜lsa,
ortiqcha indeks qoâ€˜shishdan saqlanish kerak.

3ï¸âƒ£ Indexlangan ustunlarni ALTER qilishda âŒ (Sekinlashtiradi)
ALTER TABLE orqali indekslangan ustunni oâ€˜zgartirish
(oâ€˜lchamini oâ€˜zgartirish, turini almashtirish) juda sekin bajariladi,
chunki MySQL indeksni qayta qurishga majbur boâ€˜ladi.
Ba'zi holatlarda, avval indeksni oâ€˜chirib (DROP INDEX),
soâ€˜ng ALTER TABLE bajarib, keyin indeksni qayta yaratish (CREATE INDEX) tavsiya etiladi.

Xulosa:
âœ” Ma'lumotlarni filter qilishda â€“ indekslar soâ€˜rovlarni sezilarli tezlashtiradi.
âŒ Ma'lumotlarni insert qilishda â€“ indekslar maâ€™lumot qoâ€˜shish jarayonini sekinlashtirishi mumkin.
âŒ Indexlangan ustunlarni ALTER qilishda â€“ indeks mavjud boâ€˜lsa, oâ€˜zgarishlar sekin ishlaydi.
    }

    {
5. Jadvalni o'ziga JOIN qilish nima deyiladi?
COMPLETE JOIN
SELF JOIN
OBSOLETE JOIN
CROSS JOIN

Jadvalni oâ€˜ziga JOIN qilish SELF JOIN deb ataladi. âœ…

SELF JOIN nima?
SELF JOIN â€“ bu bir jadvalni oâ€˜ziga oâ€˜zi qoâ€˜shish orqali bogâ€˜lash usuli. Bu odatda, jadvaldagi maâ€™lumotlar orasidagi bogâ€˜liqlikni topish uchun ishlatiladi.

Misol:
Faraz qilaylik, bizda employee jadvali bor va har bir xodim oâ€˜zining manager_id orqali boshligâ€˜iga bogâ€˜langan.
Biz har bir xodimni va ularning boshligâ€˜ini koâ€˜rmoqchimiz:

sql
Copy
Edit
SELECT e1.name AS Employee, e2.name AS Manager
FROM employee e1
LEFT JOIN employee e2 ON e1.manager_id = e2.id;
ğŸ”¹ e1 â€“ oddiy xodimlarni ifodalaydi.
ğŸ”¹ e2 â€“ shu xodimlarning boshligâ€˜ini ifodalaydi.

Agar Alining manager_id si 3 boâ€˜lsa va 3-ID dagi xodim Hasan boâ€˜lsa, natija shunday chiqadi:

Employee	Manager
Ali	Hasan
Hasan	Umar
Umar	NULL
Bu yerda Umar ning manager_id si yoâ€˜qligi sababli u NULL boâ€˜lib chiqdi.

Qolgan variantlarni tushuntirish:
âŒ COMPLETE JOIN â€“ Bunday JOIN MySQL da mavjud emas.
âŒ OBSOLETE JOIN â€“ Bu JOIN turi mavjud emas.
âŒ CROSS JOIN â€“ Har bir qatorni boshqa jadvalning har bir qatori bilan bogâ€˜laydi (kartesian koâ€˜paytma).



1ï¸âƒ£ COMPLETE JOIN âŒ (Mavjud emas)
MySQL yoki SQL standartida bunday JOIN turi yoâ€˜q.
Ehtimol, FULL OUTER JOIN (chap va oâ€˜ng JOIN birikmasi)
bilan adashtirilgan boâ€˜lishi mumkin.

2ï¸âƒ£ OBSOLETE JOIN âŒ (Mavjud emas)
SQL da bunday JOIN mavjud emas.
"Obsolete" soâ€˜zi eskirgan, ishlatilmaydigan degan maâ€™noni anglatadi,
lekin bu JOIN turi emas.
Balki eski JOIN sintaksislari haqida gap ketayotgandir
(masalan, FROM table1, table2 WHERE table1.id = table2.id; kabi eski usul).

3ï¸âƒ£ CROSS JOIN âœ… (Mavjud)
CROSS JOIN â€“ bu kartesian koâ€˜paytma (Cartesian Product) hosil qiladi.
Har bir jadvalning har bir qatori bilan barcha kombinatsiyalarni yaratadi.
ğŸ”¹ Misol:
Agar A jadvali da 3 qator, B jadvali da 2 qator boâ€˜lsa, CROSS JOIN natijasida 3 Ã— 2 = 6 qator hosil boâ€˜ladi.

SELECT * FROM A
CROSS JOIN B;
ğŸ’¡ Agar ON sharti berilmasa, CROSS JOIN barcha kombinatsiyalarni chiqaradi.

Xulosa:
âœ… CROSS JOIN â€“ MySQL va SQL da mavjud.
âŒ COMPLETE JOIN â€“ SQL da mavjud emas (ehtimol, FULL OUTER JOIN nazarda tutilgan).
âŒ OBSOLETE JOIN â€“ SQL da mavjud emas (eski sintaksis bilan bogâ€˜liq boâ€˜lishi mumkin).
    }

    {
6. Diskda o'qish va yozish operatsiyalari vaqtini minimallashitirish uchun
   bulardan qaysi birini tanlash kerak? CHAR yoki VARCHAR?
CHAR            -- standart holatda CHAR da o'qish yozish tez
VARCHAR         <-- bu testda ma'lumotlar xotiradan joy egallab sekinlashitirish mumkinligi uchun VARCHAR to'g'ri deb olingan
Bularning ahamiyati yo'q

Toâ€˜gâ€˜ri javob: CHAR âœ…

Agar diskda oâ€˜qish va yozish operatsiyalarini minimallashtirish kerak boâ€˜lsa,
CHAR turi VARCHAR ga nisbatan yaxshiroq ishlaydi.

Nima uchun CHAR tezroq?
1ï¸âƒ£ Fiksirlangan uzunlik
CHAR har doim belgilangan uzunlikdagi maâ€™lumotni saqlaydi
(masalan, CHAR(10) har doim 10 bayt egallaydi,
hatto maâ€™lumot 5 ta belgi boâ€˜lsa ham).
VARCHAR esa maâ€™lumot uzunligiga qarab joy egallaydi
va har bir qator uzunligi bilan bogâ€˜liq qoâ€˜shimcha 2 bayt
(VARCHAR(255) gacha) yoki 4 bayt (VARCHAR(256 va undan katta) saqlaydi.

2ï¸âƒ£ Tezroq oâ€˜qish va yozish
CHAR qatâ€™iy uzunlikda boâ€˜lgani uchun MySQL qatorlarni diskda doim bir xil
joyga joylashtiradi, bu esa tezroq qidiruv va oâ€˜qish imkonini beradi.
VARCHAR esa uzunlik oâ€˜zgarishi sababli diskda parchalanish
(fragmentation) yuzaga kelishi mumkin, bu esa tezlikni pasaytiradi.

3ï¸âƒ£ CACHE va INDEX samaradorligi
CHAR fiksirlangan uzunlikda boâ€˜lgani uchun index lar
yaxshiroq ishlaydi va CACHE samaraliroq boâ€˜ladi.

Qachon VARCHAR ishlatish kerak?
âœ… Agar maâ€™lumot uzunligi juda oâ€˜zgaruvchan boâ€˜lsa
(masalan, ism, manzil, sharh kabi maydonlar)
â€“ VARCHAR ni ishlatish yaxshiroq, chunki u ortiqcha joy egallamaydi.
âŒ Ammo, agar maâ€™lumot doim bir xil uzunlikda boâ€˜lsa
(masalan, telefon raqami, PIN-kod, mamlakat kodi) â€“ CHAR yaxshi tanlov!

Xulosa:
âœ” Disk oâ€˜qish/yozish vaqtini minimallashtirish uchun â€“ CHAR âœ…
âœ” Maâ€™lumot uzunligi oâ€˜zgaruvchan boâ€˜lsa â€“ VARCHAR âœ…
    }

    {
7. Quyidagilarni qaysi biri to'g'ri?
butun sonni taqqoslash satrlarni taqqoslashdan tezroq
satrlarni solishtirish butun sonni taqqoslashdan tezroq
ikkisi ham to'g'ri emas

To'g'ri javob: Butun sonni taqqoslash satrlarni taqqoslashdan tezroq.

Nega?
Ma'lumotlar turlari va saqlash usuli:
Butun sonlar (INTEGER, BIGINT, SMALLINT, va h.k.) MySQL tomonidan qat'iy o'lchamda
va ikkiyuzlik (binary) formatda saqlanadi.
Bu esa operatsiyalarni tezroq bajarishga imkon beradi.
Satrlar (VARCHAR, TEXT) esa har xil uzunlikka ega bo'lishi mumkin
va MySQL ularni taqqoslashda har bir belgini tekshirishiga to'g'ri keladi.

Taqqoslash usuli:
Butun sonlarni taqqoslash oddiy arifmetik operatsiyalarga asoslanadi
(<, >, = va h.k.), bu juda tez amalga oshiriladi.
Satrlarni taqqoslash esa harflarni birma-bir solishtirishni talab qiladi.
MySQL indekslash va kodlash usuliga qarab, bu nisbatan sekin bo'lishi mumkin.

Indekslash ta'siri:
MySQL butun son ustunlari uchun B-tree yoki Hash index kabi
samarali indeks turlaridan foydalana oladi,
bu esa qidiruv va taqqoslash jarayonlarini tezlashtiradi.
Satr ustunlari indekslangan bo'lsa ham,
taqqoslash ko'proq vaqt talab qilishi mumkin,
chunki MySQL avval satrlarning uzunligini tekshirishi,
keyin harflarni birma-bir taqqoslashi kerak bo'ladi.

Xulosa:
Butun sonlarni taqqoslash satrlarni taqqoslashdan tezroq,
chunki bu jarayon kamroq hisoblash va tekshirish talab qiladi.
Shu sababli, agar ma'lumotni qidirish va taqqoslash jarayonini
optimallashtirmoqchi bo'lsangiz,
imkon qadar butun sonlardan foydalanish tavsiya etiladi.
    }


{
   8. Qaysi JOIN da boshqa jadval mazmunidan qat'iy nazar
   Asosiy jadvaldagi qatorlarni barchasi natijada ko'rinadi?
RIGHT JOIN
LEFT JOIN       <--
INNER JOIN
CROSS JOIN
}

{
    9. Virtual jadvalni nimadan yaratish mumkin?
    bitta jadvaldan
    ko'p jadvallardan
    boshqa virtual jadvallardan
    yuqoridagilarning barchasidan       <--
}

{
    10. Subquery qaysi holatda faqat bitta qiymat qaytarish shart?
    SELECT bandida ishlatilayotganda        <--
    JADVAL sifatida ishlatilayotganda
    JOIN qilinayotgan jadval sifatida ishlatilayotganda

    Toâ€˜gâ€˜ri javob: SELECT bandida ishlatilayotganda

    Nega?
    Subquery (SELECT ichidagi qoâ€˜shimcha soâ€˜rov) MySQLda turli holatlarda ishlatiladi,
    lekin baâ€™zi joylarda u faqat bitta qiymat (yaâ€™ni, bitta satr va bitta ustun)
    qaytarishi shart boâ€˜ladi.

    1. SELECT bandida ishlatilayotganda (Scalar Subquery) â€“ faqat bitta qiymat kerak
    Agar subquery SELECT bandida ishlatilayotgan boâ€˜lsa, u faqat bitta qiymat qaytarishi kerak.
    Aks holda, MySQL xatolik beradi.

    âœ— Xatolik yuzaga keladigan holat:
    USE classicmodels;
     SELECT (SELECT customerNumber FROM payments WHERE amount > 2000) AS customerlar FROM payments;
    ERROR: 1242 (21000): Subquery returns more than 1 row   -- subquery 1 dan ziyoda qator qaytardi

     SELECT (SELECT name FROM users WHERE age > 30) AS user_name;
    Agar age > 30 shartiga mos keladigan bir nechta foydalanuvchi boâ€˜lsa,
    subquery koâ€˜p natija qaytaradi va MySQL
    "Subquery returns more than 1 row" xatosini chiqaradi.

    âœ” Toâ€˜gâ€˜ri variant:
    SELECT (SELECT name FROM users WHERE id = 1) AS user_name;
    Bu yerda subquery faqat bitta qiymat qaytaradi,
    shuning uchun xatolik yuzaga kelmaydi.

    2. FROM bandida jadval sifatida ishlatilayotganda (Table Subquery) â€“
    koâ€˜p natija qaytarsa ham boâ€˜ladi
    Agar subquery FROM bandida ishlatilsa, u jadval sifatida harakat qiladi
    va bir nechta satr qaytarishi mumkin.

    âœ” Toâ€˜gâ€˜ri ishlatish:
    SELECT * FROM (SELECT id, name FROM users WHERE age > 30) AS sub_users;
    Bu yerda subquery bir nechta qator qaytarsa ham, MySQL hech qanday xatolik bermaydi.

    3. JOIN qilinayotgan jadval sifatida ishlatilayotganda â€“
    ham bitta, ham koâ€˜p natija qaytarishi mumkin
    Agar subquery JOIN bandida ishlatilayotgan boâ€˜lsa,
    u ham bir nechta qator qaytarishi mumkin.
    Bu oddiy jadval sifatida ishlaydi.

    âœ” Toâ€˜gâ€˜ri ishlatish:
    SELECT users.name, orders.total
    FROM users
    JOIN (SELECT user_id, SUM(amount) AS total FROM orders GROUP BY user_id) AS order_summary
    ON users.id = order_summary.user_id;
    Bu yerda subquery bir nechta foydalanuvchi boâ€˜yicha natija qaytarishi mumkin
    va hech qanday muammo boâ€˜lmaydi.

    Xulosa
    SELECT bandida ishlatilgan subquery faqat bitta qiymat qaytarishi shart,
    chunki MySQL faqat bitta qiymatni oâ€˜zgaruvchi sifatida ishlata oladi.
    FROM yoki JOIN bandida ishlatilayotgan subquery bir nechta natija qaytarsa ham boâ€˜ladi,
    chunki ular jadval sifatida ishlaydi.
}

{
    11. JOIN qilishning qaysi turi asosiy jadvaldan faqat JOIN qilinayotgan jadvalga mos
    kelganlarini lekin JOIN bo'layotgan jadvaldan hammasini olib chiqadi?
    LEFT OUTER JOIN (LEFT JOIN)
    RIGHT OUTER JOIN (RIGHT JOIN)   <--
    FULL OUTER JOIN (INNER JOIN)
}

{
    12. SUBQUERY ni qaysi turida shu so'rovni o'zini alohida so'rov
    sifatida ishlatib bo'lmaydi?
    Correlated      <--
    Uncorrelated
    Hamma turini ishlatsa bo'ladi

    Toâ€˜gâ€˜ri javob: Correlated

    Nega?
    Subquery turlari ikkita:
    Uncorrelated (Mustaqil) Subquery â€“ Asosiy soâ€˜rovdan mustaqil ishlaydi.
    Correlated (Bogâ€˜langan) Subquery â€“ Asosiy soâ€˜rovga bogâ€˜liq boâ€˜ladi,
    yaâ€™ni har bir asosiy soâ€˜rov qatori uchun qayta ishlaydi.
    1. Correlated Subquery â€“ Alohida ishlatib boâ€˜lmaydi
    Bogâ€˜langan subquery asosiy soâ€˜rovning har bir qatoriga bogâ€˜liq boâ€˜lib ishlaydi.
    Shu sababli, uni asosiy soâ€˜rovdan ajratib, alohida ishga tushirib boâ€˜lmaydi.

    âœ— Xatolik yuzaga keladigan holat:
    SELECT name
    FROM users u
    WHERE EXISTS (
        SELECT 1 FROM orders o WHERE o.user_id = u.id
    );
    Bu yerda subquery users jadvalidagi u.id ustuniga bogâ€˜langan.
    Agar biz faqat subqueryni alohida ishlatmoqchi boâ€˜lsak:
    SELECT 1 FROM orders o WHERE o.user_id = u.id;  -- XATO! `u.id` mavjud emas
    Bu ishlamaydi, chunki u.id qiymati asosiy soâ€˜rovdan kelmoqda.

    âœ” Toâ€˜gâ€˜ri ishlatish:
    Correlated subquery faqat asosiy soâ€˜rov ichida ishlaydi.

    2. Uncorrelated Subquery â€“ Alohida ishlatsa boâ€˜ladi
    Uncorrelated subquery asosiy soâ€˜rovga bogâ€˜liq emas,
    shuning uchun uni mustaqil ishlatish mumkin.

    âœ” Toâ€˜gâ€˜ri misol:
    SELECT name FROM users WHERE id IN (
        SELECT user_id FROM orders WHERE amount > 100
    );
    Bu yerda subquery asosiy soâ€˜rovga bogâ€˜liq emas, shuning uchun uni alohida ishlatish mumkin:
    SELECT user_id FROM orders WHERE amount > 100;  -- Ishlaydi

    Xulosa
    âœ… Correlated Subquery â€“ Asosiy soâ€˜rovga bogâ€˜liq boâ€˜lgani uchun uni alohida ishlatib boâ€˜lmaydi.
    âœ… Uncorrelated Subquery â€“ Asosiy soâ€˜rovdan mustaqil boâ€˜lgani uchun uni alohida ishlatish mumkin.
    âœ… Hamma turini ishlatsa boâ€˜ladi â€“ notoâ€˜gâ€˜ri, chunki Correlated subquery mustaqil ishlamaydi.
}

{
    13. Bir nechta qidiruvlarni birlashitirish uchun biz bir nechta SELECT ifodasini yozamiz
    va ularning orasiga qaysi kalit so'zni qo'yamiz?
    COMBINE
    CONCAT
    JOIN
    UNION       <--     jadvallarni birlashitirish nazarda tutilmoqda!
}

{
    14. Bulardan qaysi biri virtual jadval deb ham ataladi?
    SCHEMA      -- DATABASE sinonimi
    DATABASE
    JOIN
    VIEW    <--
}

{
    15. Jadval yaratilgan quyidagi index lardan qaysi biri ma'lumotlar bazasi serveri
    tomonidan avtomatik tarzda yaratiladi?
    UNIQUE
    IMPLICIT
    SINGLE-COLUMN
    COMPOSITE

    Toâ€˜gâ€˜ri javob: IMPLICIT (Yashirin indeks)

    Nega?
    Maâ€™lumotlar bazasi serveri IMPLICIT (yashirin) indeksni avtomatik tarzda yaratadi,
    chunki u birlamchi kalit (PRIMARY KEY) yoki UNIQUE cheklov (CONSTRAINT)
    boâ€˜lgan ustunlar uchun avtomatik ravishda indeks yaratadi.

    IMPLICIT (Yashirin) indeks nima?
    Bu foydalanuvchi qoâ€˜lda yaratmagan, lekin MySQL avtomatik yaratadigan indeks turidir.
    Quyidagi holatlarda IMPLICIT indeks avtomatik hosil boâ€˜ladi:

    1ï¸âƒ£ PRIMARY KEY e'lon qilinganda
    CREATE TABLE users (
        id INT PRIMARY KEY,
        name VARCHAR(100)
    );
    âœ… MySQL id ustuni uchun avtomatik indeks yaratadi.

    2ï¸âƒ£ UNIQUE cheklov e'lon qilinganda
    CREATE TABLE users (
        id INT,
        email VARCHAR(255) UNIQUE
    );
    âœ… MySQL email ustuni uchun avtomatik indeks yaratadi, chunki UNIQUE cheklov mavjud.

    Boshqa indekslar avtomatik yaratiladimi?
    ğŸ”¹ UNIQUE indeks â†’ Yoq, avtomatik emas

    UNIQUE indeks IMPLICIT indeks yaratishiga sabab boâ€˜lishi mumkin,
    lekin foydalanuvchi ham uni qoâ€˜lda yaratishi mumkin.
    ğŸ”¹ SINGLE-COLUMN indeks â†’ Yoq, avtomatik emas

    Bu bitta ustun uchun maxsus yaratilgan indeks boâ€˜lib, uni MySQL avtomatik yaratmaydi.
    Foydalanuvchi qoâ€˜lda yaratishi kerak:
    CREATE INDEX idx_name ON users(name);
    ğŸ”¹ COMPOSITE indeks (Koâ€˜p ustunli indeks) â†’ Yoq, avtomatik emas

    Bir nechta ustunlarga asoslangan indeks boâ€˜lib, MySQL uni avtomatik yaratmaydi.
    Masalan, foydalanuvchi qoâ€˜lda yaratishi kerak:
     CREATE INDEX idx_multi ON orders(user_id, product_id);
    Xulosa
    âœ… IMPLICIT indeks â€“ MySQL tomonidan PRIMARY KEY yoki UNIQUE mavjud boâ€˜lganda
    avtomatik ravishda yaratiladi.
    âŒ Boshqa indekslar â€“ Foydalanuvchi tomonidan qoâ€˜lda yaratilishi kerak.
}

{
    16. WHERE bandida ma'lumotlarni agregat funksiyalar orqali filtr qilsa bo'ladimi?
    Yo'q;
    ha, faqat integer bo'lgan ma'lumotlarni;
    ha, faqat agregat funskiya subquery da foydalanilgan bo'lsa;
    ha har qanday holatda;

    Toâ€˜gâ€˜ri javob: "ha, faqat agregat funksiya subquery da foydalanilgan boâ€˜lsa"

    Nega agregat funksiyalarni WHERE bandida ishlatib boâ€˜lmaydi?
    WHERE bandi qatorlarni filtrlaydi, lekin agregat funksiyalar
    (SUM(), AVG(), COUNT(), MAX(), MIN())
    guruhlangan natijalarga ishlaydi.

    Agar agregat funksiyani bevosita WHERE bandida ishlatishga harakat qilsak,
    MySQL xato beradi, chunki WHERE individual qatorlar bilan ishlaydi,
    agregat funksiyalar esa guruhlangan natijalarga asoslangan.

    âŒ Xato kod:
    SELECT * FROM orders
    WHERE SUM(amount) > 1000;  -- Xatolik! Agregat funksiya WHERE da ishlay olmaydi.
    MySQL shunday xatolik beradi:

    "Invalid use of group function"

    Agregat funksiyalar qayerda ishlatilishi mumkin?
    1ï¸âƒ£ HAVING bandida
    HAVING â€“ guruhlangan natijalar boâ€˜yicha filtr qilish uchun ishlatiladi.

    âœ” Toâ€˜gâ€˜ri ishlatish:
    SELECT customer_id, SUM(amount) AS total_amount
    FROM orders
    GROUP BY customer_id
    HAVING SUM(amount) > 1000;
    âœ… HAVING agregat funksiyalar bilan ishlay oladi, chunki u GROUP BY dan keyin ishlaydi.

    2ï¸âƒ£ Subquery (ichki soâ€˜rov) bilan WHERE bandida
    Agregat funksiyalarni WHERE ichida ishlatish uchun subquery kerak.

    âœ” Toâ€˜gâ€˜ri ishlatish:
    SELECT * FROM orders
    WHERE amount > (SELECT AVG(amount) FROM orders);
    âœ… Bu yerda subquery birinchi boâ€˜lib AVG(amount) ni hisoblaydi,
    soâ€˜ng asosiy WHERE bandi oddiy qiymat bilan taqqoslaydi.

    Boshqa variantlar nega notoâ€˜gâ€˜ri?
    âŒ "Yoâ€˜q" â€“ notoâ€˜gâ€˜ri, chunki agregat funksiyalarni HAVING
    yoki subquery orqali ishlatsa boâ€˜ladi.

    âŒ "Ha, faqat integer boâ€˜lgan maâ€™lumotlarni" â€“ notoâ€˜gâ€˜ri,
    chunki MySQL har qanday turdagi maâ€™lumotlar bilan ishlay
    oladi (SUM(), AVG(), COUNT(), va h.k.).

    âŒ "Ha, har qanday holatda" â€“ notoâ€˜gâ€˜ri, chunki WHERE bandida
    toâ€˜gâ€˜ridan-toâ€˜gâ€˜ri agregat funksiyalar ishlatilmaydi,
    faqat HAVING yoki subquery bilan ishlaydi.

    Xulosa
    âœ… Agregat funksiyalarni WHERE bandida ishlatish uchun subquery kerak.
    âœ… Yoki HAVING bandidan foydalanish mumkin.
    âŒ Toâ€˜gâ€˜ridan-toâ€˜gâ€˜ri WHERE ichida ishlatib boâ€˜lmaydi.
}

{
    17. Ushbu taqqoslashlarning qaysi biri sekinroq ishlaydi?
    INT/INT
    INT/BIGINT      <--
    BIGINT/BIGINT

    Toâ€˜gâ€˜ri javob: INT/BIGINT taqqoslash sekinroq ishlaydi.

    Nega INT/BIGINT eng sekin?
    MySQL taqqoslash vaqtida maâ€™lumot turlarini moslashtirish
    (type conversion) kerak boâ€˜lishi mumkin.

    Quyidagi sabablar tufayli INT/BIGINT taqqoslash sekinroq ishlaydi:

    1ï¸âƒ£ Maâ€™lumot turlarini oâ€˜zgartirish (Implicit Type Conversion)

    INT 4 bayt oâ€˜lchamdagi butun son.
    BIGINT 8 bayt oâ€˜lchamdagi butun son.
    INT va BIGINT taqqoslanganda, MySQL INT ni avtomatik BIGINT ga aylantiradi,
    bu esa qoâ€˜shimcha vaqt talab qiladi.

    2ï¸âƒ£ Qiyoslash uchun qoâ€˜shimcha hisob-kitoblar

    Agar INT va BIGINT ni taqqoslash kerak boâ€˜lsa,
    har bir INT qiymati BIGINT formatiga oâ€˜tkaziladi,
    soâ€˜ngra taqqoslash amalga oshiriladi.
    Bu qoâ€˜shimcha operatsiyalarni talab qiladi, shuning uchun sekin ishlaydi.
    Boshqa variantlar qanday ishlaydi?

    âœ… INT/INT â€“ Eng tez
    Ikkala qiymat ham 4 bayt boâ€˜lgani uchun hech qanday konversiya kerak emas.
    MySQL bevosita taqqoslashni amalga oshiradi.

    âœ… BIGINT/BIGINT â€“ Tez
    Ikkala qiymat ham 8 bayt, hech qanday oâ€˜zgarish kerak emas.
    INT/INT ga qaraganda koâ€˜proq xotira talab qilishi mumkin,
    lekin baribir INT/BIGINT dan tezroq ishlaydi.

    âŒ INT/BIGINT â€“ Eng sekin
    INT (4 bayt) â†’ BIGINT (8 bayt) konversiya boâ€˜ladi.
    Har bir qator uchun bu qoâ€˜shimcha vaqt talab qiladi.

    Xulosa
    ğŸš€ Eng tez: INT/INT
    âš¡ Oâ€˜rtacha tezlik: BIGINT/BIGINT
    ğŸŒ Eng sekin: INT/BIGINT (chunki INT â†’ BIGINT konversiya boâ€˜ladi)

    â¡ Optimallashtirish tavsiyasi: Agar INT ustun bilan BIGINT
    ustunni taqqoslash kerak boâ€˜lsa, ikkala ustunni bir xil turga
    aylantirish yaxshiroq (INT ni BIGINT ga yoki aksincha).
}

{
    18. Quyidagilardan qaysi birida tranzaksiyalar haqida noto'g'ri
    ma'lumot berilgan?

    Tranzaksiya bittadan ortiq operatsiyalarni hammasi muvaffaqiyatli
    bo'gandagina bazaga o'zgartirish kiritish kerak bo'lganda ishlatiladi;
    Tranzaksiya ichidagi barcha operatsiyalar muvaffaqiyatli yoki muvaffaqiyatsiz
    bo'lishi kerak;
    COMMIT qilingan ma'lumotlarni ROLLBACK qilish imkoni bor;   <--

    Toâ€˜gâ€˜ri javob: "COMMIT qilingan ma'lumotlarni ROLLBACK qilish imkoni bor" â€“ notoâ€˜gâ€˜ri.

    Nega notoâ€˜gâ€˜ri?
    COMMIT qilingan tranzaksiya butunlay bazaga saqlanadi va
    uni ROLLBACK bilan bekor qilib boâ€˜lmaydi.

    âœ— Notoâ€˜gâ€˜ri fikr:
    START TRANSACTION;
    UPDATE users SET balance = balance - 100 WHERE id = 1;
    COMMIT;
    ROLLBACK;  -- Ishlamaydi! Chunki COMMIT allaqachon bajarilgan.
    âœ… ROLLBACK faqat COMMIT bajarilmagan tranzaksiyalar uchun ishlaydi.

    Agar COMMIT bajarilgan boâ€˜lsa, faqat quyidagi usullar
    bilan oâ€˜zgarishlarni qaytarish mumkin:

    Yangi tranzaksiya yaratish va orqaga qaytarish:
    START TRANSACTION;
    UPDATE users SET balance = balance + 100 WHERE id = 1;
    COMMIT;
    Zaxira nusxadan (backup) qayta tiklash.
    Boshqa ikkita variant toâ€˜gâ€˜ri
    âœ… 1. "Tranzaksiya bittadan ortiq operatsiyalarni hammasi
    muvaffaqiyatli boâ€˜lgandagina bazaga oâ€˜zgartirish kiritish kerak boâ€˜lganda ishlatiladi."

    Ha, tranzaksiya koâ€˜p bosqichli operatsiyalarni xavfsiz bajarish uchun ishlatiladi.
    Agar tranzaksiya ichidagi barcha operatsiyalar muvaffaqiyatli
    bajarilsa, COMMIT orqali tasdiqlanadi.
    Agar xatolik yuz bersa, ROLLBACK orqali bekor qilinadi.
    âœ” Toâ€˜gâ€˜ri misol:
    START TRANSACTION;
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    UPDATE accounts SET balance = balance + 100 WHERE id = 2;
    COMMIT;  -- Agar hamma operatsiya muvaffaqiyatli bajarilgan boâ€˜lsa

    âŒ Agar xatolik yuz bersa:
    ROLLBACK;  -- Hamma operatsiyalar bekor qilinadi


    âœ… 2. "Tranzaksiya ichidagi barcha operatsiyalar muvaffaqiyatli
    yoki muvaffaqiyatsiz boâ€˜lishi kerak."

    Ha, tranzaksiya atomik (boâ€˜linmas) tamoyilga asoslangan.
    Yaâ€™ni, yoki hamma operatsiya bajariladi, yoki hech biri bajarilmaydi (ROLLBACK).

    Xulosa
    âŒ Notoâ€˜gâ€˜ri javob:

    "COMMIT qilingan ma'lumotlarni ROLLBACK qilish imkoni bor"
    â†’ Bu notoâ€˜gâ€˜ri, chunki COMMIT bajargandan keyin ROLLBACK ishlamaydi.
}

{
    19. Quyidagilarning qaysi biri jadvallarni birlashtirishning
    asosiy usullaridan biri hisoblanadi?

    SUBQUERY lar;
    UNION JOIN;
    NATURAL JOIN;
    Yuqaridagilarning barchasi;   <--
}

{
    20. Quyidagilarning qaysi biri INDEX yaratish buyrug'i?
    CREATE INDEX index_nomi ON jadval_nomi;     <--
    INSERT INDEX index_nomi ON database_nomi;
    CREATE INDEX index_nomi ON database_nomi;
    INSERT INDEX index_nomi ON jadval_nomi;
}

{
    21. GROUP BY bandi SQL da qaysi banddan oldin qo'yiladi?
    WHERE
    ORDER BY    <--
    FROM

                            SQL yozilish tartibi
    Yozilish tartibi	SQL operatori	  Vazifasi
    1ï¸âƒ£	                SELECT	          Qaytariladigan ustunlarni tanlash
    2ï¸âƒ£	                FROM	          Jadval(lar)ni belgilash
    3ï¸âƒ£	                JOIN	          Jadvallarni bogâ€˜lash (Agar kerak boâ€˜lsa)
    4ï¸âƒ£	                WHERE	          Qatorlarni filtrlash
    5ï¸âƒ£	                GROUP BY	      Guruhlash (Agregat funksiyalar uchun)
    6ï¸âƒ£	                HAVING	          Guruhlangan natijalarni filtrlash
    7ï¸âƒ£	                ORDER BY	      Natijalarni saralash
    8ï¸âƒ£	                LIMIT / OFFSET	  Natijalarni cheklash va sahifalash
        Xulosa
    ğŸŸ¢ SQL yozish tartibi doim bir xil boâ€˜lishi kerak.
    ğŸŸ¢ WHERE oddiy qatorlarni filtrlash uchun, HAVING guruhlangan natijalarni filtrlash uchun ishlatiladi.
    ğŸŸ¢ ORDER BY va LIMIT har doim eng oxirida yoziladi.

                        SQL amallari bajarilish tartibi
    Bajarilish tartibi	        SQL operatori
    1ï¸âƒ£ FROM	                    Jadval(lar) tanlanadi
    2ï¸âƒ£ JOIN	                    Agar kerak boâ€˜lsa, bogâ€˜lash amalga oshiriladi
    3ï¸âƒ£ WHERE	                Qatorlar filtrlanadi
    4ï¸âƒ£ GROUP BY	                Guruhlash amalga oshiriladi
    5ï¸âƒ£ HAVING	                Guruhlangan natijalar filtrlanadi
    6ï¸âƒ£ SELECT	                Ustunlar tanlanadi, hisob-kitoblar amalga oshiriladi
    7ï¸âƒ£ DISTINCT	                Noyob natijalar ajratiladi
    8ï¸âƒ£ ORDER BY	                Natijalar saralanadi
    9ï¸âƒ£ LIMIT / OFFSET	        Natijalar soni cheklanadi

    Xulosa
    Birinchi bajariladigan operatorlar: FROM, JOIN, WHERE
    Agregatlar bilan ishlaydiganlar: GROUP BY, HAVING
    Soâ€˜nggi bajariladigan operatorlar: ORDER BY, LIMIT
    Yoâ€˜qolgan xatolik: SELECT eng oxirida bajariladi,
    shuning uchun WHERE ichida agregat funksiyalar ishlamaydi.
    ğŸš€ Optimallashtirish boâ€˜yicha tavsiya:
    âœ… Avval WHERE bilan keraksiz qatorlarni yoâ€˜q qilish, keyin GROUP BY va HAVING ishlatish.
    âœ… LIMIT va ORDER BY soâ€˜ngida ishlaydi, shuning uchun natijani iloji boricha avval qisqartirish muhim.
}

{
    22. JOIN natijalarini filtrlaydigan band _____ deb ataladi.
    SORT
    WHERE   <--
    GROUP
    GROUP BY
}

{
    23. Jadvalning 2 yoki undan ko'p ustunlarini indexlash bu ____.
    IMPLICT INDEX
    UNIQUE INDEX
    SINGLE-COLUMN INDEX
    COMPOSITE INDEX     <--

    SQL indeks turlari va ularning izohi
    SQL-da indekslar ma'lumotlarni tezroq qidirish va tanlash uchun ishlatiladi.
    Quyida indekslarning turlari va ularning farqlari tushuntirilgan.

    1ï¸âƒ£ IMPLICIT INDEX (Yashirin indeks, avtomatik yaratiladigan indeks)
    ğŸ”¹ IMPLICIT INDEX - bu bazaga avtomatik tarzda qoâ€˜shiladigan indeks.
    ğŸ”¹ PRIMARY KEY va UNIQUE constraint (takrorlanmas ustun)
       belgilangan ustunlarda MySQL oâ€˜z-oâ€˜zidan indeks yaratadi.
    ğŸ”¹ Foydalanuvchi bunday indeksni qoâ€˜lda yaratishi shart emas.

    âœ” Misol:
    CREATE TABLE users (
        id INT PRIMARY KEY,  -- IMPLICIT INDEX avtomatik ravishda yaratildi!
        email VARCHAR(255) UNIQUE  -- IMPLICIT INDEX avtomatik ravishda yaratildi!
    );
    âœ… "id" ustunida PRIMARY KEY bor â€“ MySQL avtomatik indeks yaratadi.
    âœ… "email" ustuni UNIQUE â€“ MySQL avtomatik indeks yaratadi.

    2ï¸âƒ£ UNIQUE INDEX (Noyob indeks)
    ğŸ”¹ UNIQUE INDEX ustundagi qiymatlar takrorlanmasligini taâ€™minlaydi.
    ğŸ”¹ IMPLICIT INDEX dan farqi â€“ bu indeksni foydalanuvchi oâ€˜zi yaratishi mumkin.

    âœ” Misol:
    CREATE UNIQUE INDEX idx_email ON users (email);
    âœ… Endi email ustunida takrorlangan qiymatlar boâ€˜lishiga ruxsat berilmaydi.

    3ï¸âƒ£ SINGLE-COLUMN INDEX (Bitta ustunli indeks)
    ğŸ”¹ SINGLE-COLUMN INDEX faqat bitta ustun boâ€˜yicha tezkor qidiruvni taâ€™minlaydi.
    ğŸ”¹ WHERE shartida faqat bitta ustun ishlatilsa, bu indeks yordam beradi.

    âœ” Misol:
    CREATE INDEX idx_lastname ON users (lastname);
    âœ… Endi SELECT * FROM users WHERE lastname = 'Smith' soâ€˜rovi tezroq bajariladi.

    4ï¸âƒ£ COMPOSITE INDEX (Koâ€˜p ustunli indeks)
    ğŸ”¹ COMPOSITE INDEX 2 yoki undan koâ€˜p ustun boâ€˜yicha qidiruvni tezlashtiradi.
    ğŸ”¹ Ketma-ketlik muhim! Indeks faqat chapdan oâ€˜ngga ishlaydi (col1, col2).
    ğŸ”¹ Koâ€˜p shartli qidiruv (WHERE col1 = X AND col2 = Y) tezroq bajariladi.

    âœ” Misol:
    CREATE INDEX idx_orders ON orders (customer_id, order_date);

    âœ… Endi quyidagi soâ€˜rov tezroq ishlaydi:
        SELECT * FROM orders WHERE customer_id = 5 AND order_date > '2024-01-01';
    âš ï¸ Muhim!

    Bu indeks customer_id boâ€˜yicha ishlaydi, keyin order_date boâ€˜yicha.
    Agar faqat order_date boâ€˜yicha qidirsangiz (WHERE order_date > '2024-01-01'),
    indeks ishlamasligi mumkin.

    Xulosa

    Indeks turi	          Ta'rifi	                                                                    Misol
    IMPLICIT INDEX	      MySQL avtomatik yaratadigan indeks (PRIMARY KEY, UNIQUE ustunlar uchun)	    PRIMARY KEY (id)
    UNIQUE INDEX	      Takrorlanmas qiymatlar boâ€˜lishini taâ€™minlaydi	                                CREATE UNIQUE INDEX idx_email ON users(email);
    SINGLE-COLUMN INDEX	  Bitta ustun boâ€˜yicha qidiruvni tezlashtiradi	                                CREATE INDEX idx_lastname ON users (lastname);
    COMPOSITE INDEX	      Ikki yoki undan ortiq ustun uchun indeks yaratadi	                            CREATE INDEX idx_orders ON orders (customer_id, order_date);

    ğŸš€ Tavsiyalar:
    âœ” Juda koâ€˜p indeks yaratish notoâ€˜gâ€˜ri â€“ chunki bu yozish (INSERT/UPDATE/DELETE) tezligini pasaytiradi.
    âœ” Agar qidiruv faqat bitta ustun boâ€˜yicha boâ€˜lsa â€“ SINGLE-COLUMN INDEX ishlating.
    âœ” Agar koâ€˜p ustun boâ€˜yicha qidiruv boâ€˜lsa â€“ COMPOSITE INDEX foydali.
}

{
    24. UNION bilan qaysi kalit so'zni ishlatilganda, bittadan ko'p bir xil
    ma'lumotlarni qaytaradi?
    NARROW
    ALL     <--
    STRICT
    DISTINCT
}

{
    25. Quyidagilarning qaysi biri to'g'ri?
    LEFT JOIN faqat JOIN shartiga javob beradigan qatorlarni oladi
    RIGHT JOIN faqat JOIN shartiga javob beradigan qatorlarni oladi
    INNER JOIN faqat JOIN shartiga javob beradigan qatorlarni oladi <--
}

TEST TAXLISI TUGADI !